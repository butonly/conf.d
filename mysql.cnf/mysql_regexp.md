mysql 正则匹配中文

用mysql里的HEX把字段转为2进制，然后正则匹配 对应中文的code码。

我们的字段存储的是utf8，所以查询了 utf8汉字编码对照表 （如果你的是gbk系的就查对应的编码对照就可以了）

汉字 e[4-9][0-9a-f]{4}
数字（3[0-9]）
字母(4[0-9A-F]|5[0-9A]|6[0-9A-F]|7[0-9A])对应的code

正则可以写为：

HEX(name) REGEXP '[[:<:]](e[4-9][0-9a-f]{4}|3[0-9]|4[0-9A-F]|5[0-9A]|6[0-9A-F]|7[0-9A]|5F)+[[:>:]]'

[[:\<:]] 和 [[:\>:]] 是 mysql正则的起止符。

REG_EXP_DATE = "^((
([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-
(
((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))
))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29))\\s+([0-1]?[0-9]|2[0-3])-([0-5][0-9])-([0-5][0-9])$";

对应数据库 YYYY-MM-DD HH24-MI-SS

(0[13578]|1[02])|(0[469]|11)|02
正则表达式中的特殊字符
字符/
意义：对于字符，通常表示按字面意义，指出接着的字符为特殊字符，不作解释。
例如：/b/匹配字符’b’,通过在b 前面加一个反斜杠，也就是/b/，则该字符变成特殊字符，表示
匹配一个单词的分界线。
或者：
对于几个字符，通常说明是特殊的，指出紧接着的字符不是特殊的，而应该按字面解释。
例如：*是一个特殊字符，匹配任意个字符(包括0个字符)；例如：/a*/意味匹配0个或多个a。为了匹配字面上的*，在a前面加一个反斜杠；例如：/a*/匹配’a*’。

字符^
意义：表示匹配的字符必须在最前边。

例如：/^A/不匹配\"an A,\"中的’A’，但匹配\"An A.\"中最前面的’A’。

字符$
意义：与^类似，匹配最末的字符。
例如：/t$/不匹配\"eater\"中的’t’，但匹配\"eat\"中的’t’。

字符*
意义：匹配*前面的字符0次或n次。
例如:/bo*/匹配\"A ghost booooed\"中的’boooo’或\"A bird warbled\"中的’b’，但不匹配\"Agoat g
runted\"中的任何字符。

字符+
意义：匹配+号前面的字符1次或n次。等价于{ 1, }。
例如：/a+/匹配\"candy\"中的’a’和\"caaaaaaandy.\"中的所有’a’。

字符?
意义：匹配?前面的字符0次或1次。
例如：/e?le?/匹配\"angel\"中的’el’和\"angle.\"中的’le’。

字符.
意义：(小数点)匹配除换行符外的所有单个的字符。
例如：/.n/匹配\"nay, an apple is on the tree\"中的’an’和’on’，但不匹配’nay’。


字符(x)
意义：匹配’x’并记录匹配的值。
例如：/(foo)/匹配和记录\"foo bar.\"中的’foo’。匹配子串能被结果数组中的素[1], ...,[n] 返
回，或被RegExp对象的属性, ..., 返回。

字符x│y
意义：匹配’x’或者’y’。
例如：/green│red/匹配\"green apple\"中的’green’和\"red apple.\"中的’red’。

字符{ n }
意义：这里的n是一个正整数。匹配前面的n个字符。
例如：/a{ 2 }/不匹配\"candy,\"中的’a’，但匹配\"caandy,\" 中的所有’a’和\"caaandy.\"中前面的两个’a’。
字符s
意义：匹配一个单个white空格符，包括空格，tab，form feed，换行符，等价于[ fnrtv]。
例如：/sw*/匹配\"foo bar.\"中的’ bar’。

字符S
意义：匹配除white空格符以外的一个单个的字符，等价于[^ fnrtv]。
例如：/S/w*匹配\"foo bar.\"中的’foo’。

字符t
意义：匹配一个制表符

字符v
意义：匹配一个顶头制表符

字符w
意义：匹配所有的数字和字母以及下划线，等价于[A-Za-z0-9_]。
例如：/w/匹配\"apple,\"中的’a’，\".28,\"中的’5’和\"3D.\"中的’3’。

字符W
意义：匹配除数字、字母外及下划线外的其它字符，等价于[^A-Za-z0-9_]。
例如：/W/或者/[^$A-Za-z0-9_]/匹配\"50%.\"中的’%’。

字符n
意义：这里的n是一个正整数。匹配一个正则表达式的最后一个子串的n的值(计数左圆括号)。

例如：/apple(,)sorange1/匹配\"apple, orange, cherry, peach.\"中的’apple, orange’，下面有一个更加完整的例子。
注意：如果左圆括号中的数字比n指定的数字还小，则n取下一行的八进制escape作为描述。

字符ooctal和xhex
意义：这里的ooctal是一个八进制的escape值，而xhex是一个十六进制的escape值，允许在一个正则表达式中嵌入ASCII码

附:下表是元字符及其在正则表达式上下文中的行为的一个完整列表：

字符 描述
\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 后向引用、或一个八进制转义符。例如，\'n\' 匹配字符 \"n\"。\'\n\' 匹配一个换行符。序列 \'\\\' 匹配 \"\\" 而 \"\(\" 则匹配 \"(\"。
^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 \'\n\' 或 \'\r\' 之后的位置。
$ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 \'\n\' 或 \'\r\' 之前的位置。
* 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。 * 等价于{0,}。
+ 匹配前面的子表达式一次或多次。例如，\'zo+\' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。
? 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 中的\"do\" 。? 等价于 {0,1}。
{n} n 是一个非负整数。匹配确定的 n 次。例如，\'o{2}\' 不能匹配 \"Bob\" 中的 \'o\'，但是能匹配 \"food\" 中的两个 o。
{n,} n 是一个非负整数。至少匹配n 次。例如，\'o{2,}\' 不能匹配 \"Bob\" 中的 \'o\'，但能匹配 \"foooood\" 中的所有 o。\'o{1,}\' 等价于 \'o+\'。\'o{0,}\' 则等价于 \'o*\'。
{n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。刘， \"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。\'o{0,1}\' 等价于 \'o?\'。请注意在逗号和两个数之间不能有空格。
? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \"oooo\"，\'o+?\' 将匹配单个 \"o\"，而 \'o+\' 将匹配所有 \'o\'。
. 匹配除 \"\n\" 之外的任何单个字符。要匹配包括 \'\n\' 在内的任何字符，请使用象 \'[.\n]\' 的模式。
(pattern) 匹配pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 {CONTENT}… 属性。要匹配圆括号字符，请使用 \'\(\' 或 \'\)\'。
(?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。例如， \'industr(?:y|ies) 就是一个比 \'industry|industries\' 更简略的表达式。
(?=pattern) 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， \'Windows (?=95|98|NT|2000)\' 能匹配 \"Windows 2000\" 中的 \"Windows\" ，但不能匹配 \"Windows 3.1\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!pattern) 负向预查，在任何不匹配Negative lookahead matches the search string at any point where a string not matching pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如\'Windows (?!95|98|NT|2000)\' 能匹配 \"Windows 3.1\" 中的 \"Windows\"，但不能匹配 \"Windows 2000\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
x|y 匹配 x 或 y。例如，\'z|food\' 能匹配 \"z\" 或 \"food\"。\'(z|f)ood\' 则匹配 \"zood\" 或 \"food\"。
[xyz] 字符集合。匹配所包含的任意一个字符。例如， \'[abc]\' 可以匹配 \"plain\" 中的 \'a\'。
[^xyz] 负值字符集合。匹配未包含的任意字符。例如， \'[^abc]\' 可以匹配 \"plain\" 中的\'p\'。
[a-z] 字符范围。匹配指定范围内的任意字符。例如，\'[a-z]\' 可以匹配 \'a\' 到 \'z\' 范围内的任意小写字母字符。
[^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，\'[^a-z]\' 可以匹配任何不在 \'a\' 到 \'z\' 范围内的任意字符。
\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， \'er\b\' 可以匹配\"never\" 中的 \'er\'，但不能匹配 \"verb\" 中的 \'er\'。
\B 匹配非单词边界。\'er\B\' 能匹配 \"verb\" 中的 \'er\'，但不能匹配 \"never\" 中的 \'er\'。
\cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。 x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 \'c\' 字符。
\d 匹配一个数字字符。等价于 [0-9]。
\D 匹配一个非数字字符。等价于 [^0-9]。
\f 匹配一个换页符。等价于 \x0c 和 \cL。
\n 匹配一个换行符。等价于 \x0a 和 \cJ。
\r 匹配一个回车符。等价于 \x0d 和 \cM。
\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t 匹配一个制表符。等价于 \x09 和 \cI。
\v 匹配一个垂直制表符。等价于 \x0b 和 \cK。
\w 匹配包括下划线的任何单词字符。等价于\'[A-Za-z0-9_]\'。
\W 匹配任何非单词字符。等价于 \'[^A-Za-z0-9_]\'。
\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如， \'\x41\' 匹配 \"A\"。\'\x041\' 则等价于 \'\x04\' & \"1\"。正则表达式中可以使用 ASCII 编码。.
\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，\'(.)\1\' 匹配两个连续的相同字符。
\n 标识一个八进制转义值或一个后向引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为后向引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
\nm 标识一个八进制转义值或一个后向引用。如果 \nm 之前至少有is preceded by at least nm 个获取得子表达式，则 nm 为后向引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的后向引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。

自己总结的正则表达式：绝对正确的，本人已经验证通过了。

1. 只有字母、数字和下划线且不能以下划线开头和结尾的正则表达式：^(?!_)(?!.*?_$)[a-zA-Z0-9_]+$
2. 只有字母和数字的： ^[a-zA-Z0-9_]+$
3. 至少一个汉字、数字、字母、下划线: "[a-zA-Z0-9_\u4e00-\u9fa5]+"
4. 至少一个汉字的正则表达式："^[\u4e00-\u9fa5]"
5. 最多10个汉字: ValidationExpression="^[\u4e00-\u9fa5]{0,10}"
6. 只含有汉字、数字、字母、下划线不能以下划线开头和结尾：^(?!_)(?!.*?_$)[a-zA-Z0-9_\u4e00-\u9fa5]+$
   解释：
        ^  与字符串开始的地方匹配
        (?!_)　　不能以_开头
        (?!.*?_$)　　不能以_结尾
        [a-zA-Z0-9_\u4e00-\u9fa5]+　　至少一个汉字、数字、字母、下划线
        $　　与字符串结束的地方匹配

7. email正则表达式：两种方式都可以
   (1) \w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
   (2) ^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*((\\.[A-Za-z]{2,}){1}$)

select `公司名称` from b2c_ss where `公司名称` REGEXP '[^\u4e00-\u9fa5]|[_]|[#]';

下面是转载的(但我验证了下怎么没有成功？又期待性)：
完美E-Mail正则表达式：
国际域名格式如下:
          域名由各国文字的特定字符集、英文字母、数字及“-”(即连字符或减号)任意组合而成,   但开头及结尾均不能含有“-”，“-”不能连续出现   。   域名中字母不分大小写。域名最长可达60个字节(包括后缀.com、.net、.org等)。


  /^[a-z]([a-z0-9]*[-_]?[a-z0-9]+)*@([a-z0-9]*[-_]?[a-z0-9]+)+[\.][a-z]{2,3}([\.][a-z]{2})?$/i;

  /内容/i   构成一个不区分大小写的正则表达式;
  ^   匹配开始
  $   匹配结束
  [a-z]   E-Mail前缀必需是一个英文字母开头

  ([a-z0-9]*[-_]?[a-z0-9]+)*   和_a_2、aaa11、_1_a_2匹配，和a1_、aaff_33a_、a__aa不匹配，如果是空字符，也是匹配的，*表示0个或者多个。
  *表示0个或多个前面的字符.
  [a-z0-9]*   匹配0个或多个英文字母或者数字
  [-_]?   匹配0个或1“-”，因为“-”不能连续出现
  [a-z0-9]+   匹配1个或多个英文字母或者数字，因为“-”不能做为结尾

  @   必需有个有@
  ([a-z0-9]*[-_]?[a-z0-9]+)+   见上面([a-z0-9]*[-_]?[a-z0-9]+)*解释，但是不能为空，+表示一个或者为多个。
  [\.]   将特殊字符(.)当成普通字符
  [a-z]{2,3}   匹配2个至3个英文字母，一般为com或者net等.
  ([\.][a-z]{2})?   匹配0个或者1个[\.][a-z]{2}(比如.cn等)   我不知道一般.com.cn最后部份是不是都是两位的,如果不是请修改{2}为{起始字数,结束字数}

下面也是转载的：
1、一个正则表达式，只含有汉字、数字、字母、下划线不能以下划线开头和结尾：
^(?!_)(?!.*?_$)[a-zA-Z0-9_\u4e00-\u9fa5]+$  其中：
^  与字符串开始的地方匹配
(?!_)　　不能以_开头
(?!.*?_$)　　不能以_结尾
[a-zA-Z0-9_\u4e00-\u9fa5]+　　至少一个汉字、数字、字母、下划线
$　　与字符串结束的地方匹配

放在程序里前面加@，否则需要\\进行转义 @"^(?!_)(?!.*?_$)[a-zA-Z0-9_\u4e00-\u9fa5]+$"
 （或者：@"^(?!_)\w*(?<!_)$"    或者  @" ^[\u4E00-\u9FA50-9a-zA-Z_]+$ "  )

2、只含有汉字、数字、字母、下划线，下划线位置不限：
  ^[a-zA-Z0-9_\u4e00-\u9fa5]+$

3、由数字、26个英文字母或者下划线组成的字符串
^\w+$

4、2~4个汉字
  @"^[\u4E00-\u9FA5]{2,4}$";

5、
^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$

用：(Abc)+    来分析：  XYZAbcAbcAbcXYZAbcAb



XYZAbcAbcAbcXYZAbcAb6、
[^\u4E00-\u9FA50-9a-zA-Z_]
34555#5' -->34555#5'

[\u4E00-\u9FA50-9a-zA-Z_]    eiieng_89_   --->   eiieng_89_
_';'eiieng_88&*9_    -->  _';'eiieng_88&*9_
_';'eiieng_88_&*9_  -->  _';'eiieng_88_&*9_

public  bool RegexName(string str)
  {
   bool flag=Regex.IsMatch(str,@"^[a-zA-Z0-9_\u4e00-\u9fa5]+$");
   return  flag;
  }

 Regex   reg=new   Regex("^[a-zA-Z_0-9]+$");
  if(reg.IsMatch(s))
  {
  \\符合规则
  }
  else
  {
  \\存在非法字符
  }
















